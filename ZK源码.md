## 选举算法源码中的总思路

Zookeeper 的 Leader 选举类是 FastLeaderElection，该类是 ZAB 协议在 Leader 选举中的工 程应用，所以直接找到该类对其进行分析。该类中的最为重要的方法为 lookForLeader()，是选举 Leader 的核心方法。该方法大体思路可以划分为以下几块：



## 选举前的准备工作

选举前需要做一些准备工作，例如，创建选举对象、创建选举过程中需要用到的集合、 初始化选举时限等。





## 将自己作为初始化 Leader 投出去

在当前 Server 第一次投票时会先将自己作为 Leader，然后将自己的选票广播给其它所 有 Server。





## 验证自己的投票与大家的投票谁更适合做 Leader

在“我选我”后，当前 Server 同样会接收到其它 Server 发送来的选票通知(Notification)。 通过while 循环，遍历所有接收到的选票通知，比较谁更适合做 Leader。若找到一个比自己 更适合的 Leader，则修改自己选票，重新将新的选票广播出去。当然，每验证一个选票，则会将其记录到一个集合中，将来用于进行票数统计。





## 判断本轮选举是否应结束

其实在每次验证过谁更适合做 Leader 后，就会马上判断当前的选举是否可以结束了， 即当前主机所推荐的这个选票是否过半了。若过半了，则直接完成后续的一些收尾工作，例 如清空选举过程中所使用的集合，以备下次使用；再例如，生成最终的选票，以备其它 Server 来同步数据。若没有过半，则继续从队列中读取出下一个来自于其它主机的选票，然后进行验证。



源码解读

需要注意，对源码的阅读主要包含两方面。一个是对重要类、重要成员变量、重要方法 的注释的阅读；一个是对重要方法的业务逻辑的分析。









吧自己的选票封装为一个对象，广播给别人，假设6个。

我坐等收到6个回应。我等待收取其他人的通知，这个等待接受6个回应的时间，就是finalizeWait。内部运算的时间很短，几乎忽略不计。所以finalizeWait是等待接收其他server发送通知的时间。

超过60秒maxNotificationInterval还没有选举出来leader，则重新发起一轮投票选举。





只要我发出了广播，不管你什么状态，都要给我一个回复。

不管我自己什么状态，只要我收到了，都要给别人一个恢复。



QuorumCnxManager

这个类使用TCP实现了一个用于Leader选举的连接管理器。它为每一对服务器维护着一个连接。棘手的部分在于确保（为每对服务器正确地操作并且可以与整个网络进行通信的）连接恰有一个。



![1567578988876](E:\github\zookeeper\images\1567578988876.png)



确保只有一个链接保持通信就够了，不需要互相链接。

![1567580082400](E:\github\zookeeper\images\1567580082400.png)

Serverid为1的server中quorumcnxmanager对象维护的消息发送状态为失败的map



key里没有1，value放的是1号主机发送给2号主机，没有发送成功，就会把没有发送成功的消息放入map。

只有失败的存入map。成功的不放入。这样就可能导致消息发送的顺序发生改变。



根据当前map中的各个value（队列）是否为空，可以判断当前Server与整个集群的连接状态。

若所有队列为空，说明当前server与集群的连接是没有任何问题的。

若所有队列不空，说明当前server与集群的连接已经完全失联。

若某一个队列不空，说明当前server与该队列的server的连接出现问题。肯定要重连的。

若某一个队列为空，说明当前server与集群的连接是没有问题的。有一个兄弟能收到，就是连接没问题



记录当前Server收到的来自于其它Server的本轮投票信息

key为投票者的serverId，value为选票

recvset集合就相当于票箱

outofelection 不合法的票箱

选票来自于Notification，Notification不管对方是什么状态，都会收到。有时候是不合法的消息。

```java
       HashMap<Long, Vote> recvset = new HashMap<Long, Vote>();
       HashMap<Long, Vote> outofelection = new HashMap<Long, Vote>();
```







